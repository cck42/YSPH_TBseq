import pandas as pd
import os

configfile: "config/config.yaml"
include: "rules/common.py"


SAMPLES = [line.strip() for line in open(config['samples'], 'r')]
SAMPLE1 = SAMPLES[0]

TARGETS = config['refs']

#container: "docker://sethnr/pgcoe_bacseq:0.01"

include: "rules/cplocal.smk"

include: "rules/align.smk"

include: "rules/ivar.smk"

include: "rules/stats.smk"

include: "rules/mykrobe.smk"

localrules: all, cp_local_fq, cp_local_data


rule all:
    input:
        combinedcoverage=os.path.join(config['outdir'],config['runname'],'combinedcoverage.tsv'),
        genedepths='results/summary/all_genedepth.txt',
        resdepths='results/summary/all_resistdepth.txt',
        mykrobecombined=config['outdir']+'/mykrobe/combined.csv'


rule coverage:
    input:
        subsamp=os.path.join(config['outdir'],'align/{sample}_subsamp.bam')
    output:
        coveragestats=os.path.join(config['outdir'],'align/{sample}_coverage_sub.tsv')
    resources:
        mem_mb=8000,
        runtime=180,
    params:
        maxdepth=0,
        minmapqual=60,
        minbasequal=13,
        subsample=config['subsample']
    container: "docker://sethnr/pgcoe_bacseq:0.01"
    log:
        stderr="logs/align/{sample}_sub.err"
    message: "Computing coverage of reference for sample {wildcards.sample} with a read subsample fraction of {params.subsample}"
    shell:
        """
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n' {wildcards.sample} {params.subsample} `samtools coverage -d {params.maxdepth} -q {params.minmapqual} -Q {params.minbasequal} --no-header {input.subsamp}` > {output.coveragestats} 2> {log.stderr}
        """



rule combinedcoverage:
    input:
        coveragestats=expand(os.path.join(config['outdir'],'align/{sample}_coverage_sub.tsv'),sample=SAMPLES)
    output:
        combinedcoverage=os.path.join(config['outdir'],config['runname'],'combinedcoverage.tsv')
    resources:
        mem_mb=8000,
        runtime=180,
    log:
        stderr="logs/coverage.err"
    shell:
        """
        {{ echo -e "sample\tsubsample\trname\tstartpos\tendpos\tnumreads\tcovbases\tcoverage\tmeandepth\tmeanbaseq\tmeanmapq";cat {input.coveragestats}; }} > {output.combinedcoverage} 2> {log.stderr}
        """

rule indexbam:
    input:
        bam = '{samplename}.bam'
    output:
        indexedbam = '{samplename}.bam.bai'
    container: "docker://sethnr/pgcoe_bacseq:0.01"
    log:
        stdout="logs/bamindex/{samplename}.out",
        stderr="logs/bamindex/{samplename}.err"
    message: "Indexing bam file: {wildcards.samplename}"
    shell:
        """
        samtools index {input.bam} > {log.stdout} 2> {log.stderr}
        """



rule variantcalling:
    input:
        tocall=expand(os.path.join(config['outdir'],'align/{sample}_aln_itrim_sorted.bam'),sample=SAMPLES),
        indexed=expand(os.path.join(config['outdir'],'align/{sample}_aln_itrim_sorted.bam.bai'),sample=SAMPLES)
    params:
        ref=config['reference']
    resources:
        mem_mb=8000,
        runtime=240,
    output:
        vcf=os.path.join(config['outdir'],'pileup',"all_variants_unfilt.vcf.gz")
    log:
        stdout="logs/variantcalling.out",
        stderr="logs/variantcalling.err"
    message: "Calling variants for all samples"
    container: "docker://sethnr/pgcoe_bacseq:0.01"
    shell:
        """
        bcftools mpileup -Ou -o variants.bcf -f {params.ref} {input.tocall} 1> {log.stdout} 2> {log.stderr}
        bcftools call --ploidy 1 -vcO z -o {output.vcf} variants.bcf 1>> {log.stdout} 2>> {log.stderr}
        tabix -p vcf {output.vcf} 1>> {log.stdout} 2>> {log.stderr}
	        
	"""

rule variantfilter:
    input:
        vcf={rules.variantcalling.output.vcf}
    output:
        vcf_filt=os.path.join(config['outdir'],'pileup',"all_variants_filt.vcf.gz")
    resources:
        mem_mb=8000,
        runtime=180,
    log:
        stdout="logs/variantfilter.out",
        stderr="logs/variantfilter.err"
    container: "docker://sethnr/pgcoe_bacseq:0.01"
    shell:
        """
        bcftools filter -O z -o {output.vcf_filt} -i 'QUAL>10 & DP>10' {input.vcf} 1> {log.stdout} 2> {log.stderr}
        """


rule catstats:
    input:
        ampdepths=lambda wildcards: expand('results/stats/{sample}_ampdepth.txt',sample=SAMPLES),
        genedepths=lambda wildcards: expand('results/stats/{sample}_genedepth.txt',sample=SAMPLES),
        resdepths=lambda wildcards: expand('results/stats/{sample}_resistdepth.txt',sample=SAMPLES),
        resists=lambda wildcards: expand('results/mykrobe/{sample}_mykrobe.csv',sample=SAMPLES),
    output:
        ampdepths= 'results/summary/all_ampdepth.txt',
        genedepths='results/summary/all_genedepth.txt',
        resdepths='results/summary/all_resistdepth.txt',
        resists='results/summary/all_resists.txt',
    group: "catstats"
    resources:
        mem_mb=8000,
        runtime=180,
    log:
        stderr="logs/depth/all_depths.err"
    shell:
        """
        cat results/stats/*_ampdepth.txt | sort -u  > {output.ampdepths}
        cat results/stats/*_genedepth.txt | sort -u  > {output.genedepths}
        cat results/stats/*_resistdepth.txt | sort -u  > {output.resdepths}
        cat results/mykrobe/*_mykrobe.csv | sort -u > {output.resists}
        """


